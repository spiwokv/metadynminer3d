#' @useDynLib metadynminer3d
#' importFrom metadynminer feprof fes fes2 fesminima oneminimum plotheights
#' @importFrom Rcpp sourceCpp
#' @importFrom misc3d contour3d
#' @importFrom rgl axes3d title3d box3d text3d points3d
NULL

#' Read 3D HILLS from Plumed
#'
#' `read.hills3d` reads a HILLS file generated by Plumed and returns a hillsfile3d object.
#' User can specify whether some collective variables are periodic.
#'
#' @param file HILLS file from Plumed.
#' @param per logical vector specifying periodicity of collective variables.
#' @param pcv1 periodicity of CV1.
#' @param pcv2 periodicity of CV2.
#' @param pcv3 periodicity of CV3.
#' @param ignoretime time in the first column of the HILLS file will be ignored.
#' @return hillsfile object.
#'
#' @export
#' @examples
#' l1<-"1 -1.587 -2.969  3.013 0.3 0.3 0.3 1.111 10"
#' l2<-"2 -1.067  2.745  2.944 0.3 0.3 0.3 1.109 10"
#' l3<-"3 -1.376  2.697  3.049 0.3 0.3 0.3 1.080 10"
#' l4<-"4 -1.663  2.922 -3.065 0.3 0.3 0.3 1.072 10"
#' fourhills<-c(l1,l2,l3,l4)
#' tf <- tempfile()
#' writeLines(fourhills, tf)
#' read.hills3d(tf, per=c(TRUE,TRUE))
read.hills3d<-function(file="HILLS", per=c(FALSE, FALSE, FALSE), pcv1=c(-pi,pi), pcv2=c(-pi,pi), pcv3=c(-pi,pi), ignoretime=FALSE) {
  hillsf<-read.table(file, header=F, comment.char="#")
  if(ncol(hillsf)==5 || ncol(hillsf)==6) {
    cat("looks like you trying to load 1D HILLS, use read.hills from metadynminer\n")
  } else if(ncol(hillsf)==7 || ncol(hillsf)==8) {
    cat("looks like you trying to load 2D HILLS, use read.hills from metadynminer\n")
  } else if(ncol(hillsf)==9 || ncol(hillsf)==10) {
    cat("3D HILLS file read\n")
    if(ignoretime) {
      cat("Warning: The time will be updated automatically from zero\n")
      cat("according to the first step!\n")
      hillsf[,1]<-seq(from=hillsf[1,1], by=hillsf[1,1], length.out=nrow(hillsf))
    }
    hills<-list(hillsfile=hillsf, time=hillsf[,1], cv1=hillsf[,2], cv2=hillsf[,3], cv3=hillsf[,4],
                size=dim(hillsf), filename=file, per=per, pcv1=pcv1, pcv2=pcv2, pcv3=pcv3)
    class(hills) <- "hillsfile3d"
    return(hills)
  } else {
    stop("Error: Number of columns in HILLS file must be 9 or 10 (3D)")
  }
}

#' Print hillsfile3d
#'
#' `print.hillsfile3d` prints dimensionality and size of a hillsfile object.
#'
#' @param x hillsfile3d object.
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' acealanme3d
print.hillsfile3d<-function(x,...) {
  hills <- x
  cat("3D hills file ")
  cat(hills$filename)
  cat(" with ")
  cat(hills$size[1])
  cat(" lines\n")
}

#' Print summary for hillsfile3d
#'
#' `summary.hillsfile3d` prints dimensionality, size and collective variable ranges of a hillsfile3d object.
#'
#' @param object hillsfile3d object.
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' summary(acealanme3d)
summary.hillsfile3d<-function(object,...) {
  hills <- object
  cat("2D hills file ")
  cat(hills$filename)
  cat(" with ")
  cat(hills$size[1])
  cat(" lines\n")
  cat("The CV1 ranges from ")
  cat(min(hills$hillsfile[,2]))
  cat(" to ")
  cat(max(hills$hillsfile[,2]))
  cat("\nThe CV2 ranges from ")
  cat(min(hills$hillsfile[,3]))
  cat(" to ")
  cat(max(hills$hillsfile[,3]))
  cat("\nThe CV3 ranges from ")
  cat(min(hills$hillsfile[,4]))
  cat(" to ")
  cat(max(hills$hillsfile[,4]))
  cat("\n")
}

#' Print first n lines of hillsfile3d
#'
#' `head.hillsfile3d` prints first n lines of a hillsfile3d object.
#'
#' @param x hillsfile3d object.
#' @param n number of lines (default 10).
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' head(acealanme3d)
head.hillsfile3d<-function(x, n=10,...) {
  return(head(x$hillsfile, n=n))
}

#' Print last n lines of hillsfile3d
#'
#' `tail.hillsfile3d` prints last n lines of a hillsfile3d object.
#'
#' @param x hillsfile3d object.
#' @param n number of lines (default 10).
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' tail(acealanme3d)
tail.hillsfile3d<-function(x, n=10,...) {
  return(tail(x$hillsfile, n=n))
}

#' @export
`+.hillsfile3d`<-function(hills1, hills2) {
  if(ncol(hills1$hillsfile)!=ncol(hills2$hillsfile)) {
    stop("Error: You can sum only hills of same dimension")
  }
  if(hills1$per[1]!=hills2$per[1]) {
    stop("Error: You can sum only hills of same periodicity")
  }
  if(ncol(hills1$hillsfile)==7 || ncol(hills1$hillsfile)==8) {
    if(hills1$per[2]!=hills2$per[2]) {
      stop("Error: You can sum only hills of same periodicity")
    }
  }
  if(ncol(hills1$hillsfile)==9 || ncol(hills1$hillsfile)==10) {
    if(hills1$per[2]!=hills2$per[2]) {
      stop("Error: You can sum only hills of same periodicity")
    }
    if(hills1$per[3]!=hills2$per[3]) {
      stop("Error: You can sum only hills of same periodicity")
    }
  }
  hills<-list(hillsfile=rbind(hills1$hillsfile, hills2$hillsfile), size=dim(rbind(hills1$hillsfile, hills2$hillsfile)),
              filename=hills1$filename, per=hills1$per, pcv1=hills1$pcv1, pcv2=hills1$pcv2, pcv3=hills1$pcv3)
  class(hills) <- "hillsfile3d"
  return(hills)
}

#' Plot hillsfile3d object
#'
#' `plot.hillsfile3d` plots hillsfile object. It plots CV1 vs CV2 vs CV3.
#'
#' @param x hillsfile object.
#' @param xlab a title for the x axis: see 'title'.
#' @param ylab a title for the y axis: see 'title'.
#' @param zlab a title for the z axis: see 'title'.
#' @param main an overall title for the plot: see 'title'.
#' @param sub a sub title for the plot: see 'title'.
#' @param col color code or name, see 'par'.
#' @param xlim numeric vector of length 2, giving the x coordinates range.
#' @param ylim numeric vector of length 2, giving the y coordinates range.
#' @param zlim numeric vector of length 2, giving the z coordinates range.
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' plot(acealanme3d)
plot.hillsfile3d<-function(x,
                           xlab="CV1", ylab="CV2", zlab="CV3",
                           xlim=NULL, ylim=NULL, zlim=NULL,
                           main=NULL, sub=NULL,
                           col="orange",...) {
  hills <-x
  xlims<-NULL
  ylims<-NULL
  zlims<-NULL
  if(!is.null(xlim)) {xlims<-xlim}
  if(!is.null(ylim)) {ylims<-ylim}
  if(!is.null(zlim)) {zlims<-zlim}
  points3d(hills$hillsfile[,2:4], col=col)
  axes3d()
  title3d(xlab=xlab, ylab=ylab, zlab=zlab,
          main=main, sub=sub)
  box3d()
}

#' Plot evolution of heights of hills in hillsfile3d object
#'
#' `plotheights.hillsfile3d` plots evolution of heights of hills. In well tempered
#' metadynamics hill heights decrees with flooding of the free energy surface.
#' Evolution of heights may be useful to evaluate convergence of the simulation.
#'
#' @param hills hillsfile object.
#' @param ignoretime time in the first column of the HILLS file will be ignored.
#' @param main an overall title for the plot: see 'title'.
#' @param sub a sub title for the plot: see 'title'.
#' @param xlab a title for the x axis: see 'title'.
#' @param ylab a title for the y axis: see 'title'.
#' @param asp the y/x aspect ratio, see 'plot.window'.
#' @param col color code or name, see 'par'.
#' @param lwd line width for drawing symbols see 'par'.
#' @param xlim numeric vector of length 2, giving the x coordinates range.
#' @param ylim numeric vector of length 2, giving the y coordinates range.
#' @param axes a logical value indicating whether both axes should be drawn
#'        on the plot.
#'
#' @export
#' @examples
#' plotheights(acealanme3d)
plotheights.hillsfile3d<-function(hills, ignoretime=FALSE,
                                  xlab=NULL, ylab=NULL,
                                  xlim=NULL, ylim=NULL,
                                  main=NULL, sub=NULL,
                                  col="black", asp=NULL, lwd=1, axes=TRUE) {
  if(is.null(xlab)) xlab="time"
  if(is.null(ylab)) ylab="hill height"
  if(ignoretime) {
    plot(seq(from=hills$hillsfile[1,1],by=hills$hillsfile[1,1],length.out=nrow(hills$hillsfile)),
         hills$hillsfile[,8], type="l",
         xlab=xlab, ylab=ylab,
         main=main, sub=sub,
         col=col, lwd=lwd,
         asp=asp, axes=axes)
  } else {
    plot(hills$hillsfile[,1], hills$hillsfile[,8], type="l",
         xlab=xlab, ylab=ylab,
         main=main, sub=sub,
         col=col, lwd=lwd,
         asp=asp, axes=axes)
  }
}

#' Calculate 3D free energy surface by Bias Sum algorithm
#'
#' `fes.hillsfile3d` sums up hills using fast Bias Sum algorithm.
#'
#' @param hills hillsfile3d object.
#' @param imin index of a hill from which summation starts (default 1).
#' @param imax index of a hill from which summation stops (default the rest of hills).
#' @param x lim numeric vector of length 2, giving the CV1 coordinates range.
#' @param ylim numeric vector of length 2, giving the CV2 coordinates range.
#' @param zlim numeric vector of length 2, giving the CV3 coordinates range.
#' @param npoints resolution of the free energy surface in number of points.
#' @return fes object.
#'
#' @export
#' @examples
#' tfes<-fes(acealanme3d, imax=5000)
fes.hillsfile3d<-function(hills, imin=1, imax=NULL, xlim=NULL, ylim=NULL, zlim=NULL, npoints=NULL) {
  if(!is.null(imax)) {
    if(hills$size[1]<imax) {
      cat("Warning: You requested more hills by imax than available, using all hills\n")
      imax<-hills$size[1]
    }
  }
  if(is.null(imax)) {
    imax<-hills$size[1]
  }
  if(imin>imax) {
    stop("Error: imax cannot be lower than imin")
  }
  if(hills$size[2]==9) {
    if(max(hills$hillsfile[,5])/min(hills$hillsfile[,5])>1.00000000001) {
      stop("Error: Bias Sum algorithm works only with hills of the same sizes")
    }
    if(max(hills$hillsfile[,6])/min(hills$hillsfile[,6])>1.00000000001) {
      stop("Error: Bias Sum algorithm works only with hills of the same sizes")
    }
    if(max(hills$hillsfile[,7])/min(hills$hillsfile[,7])>1.00000000001) {
      stop("Error: Bias Sum algorithm works only with hills of the same sizes")
    }
    if(is.null(npoints)) {
      npoints <- 64
    }
    minCV1 <- min(hills$hillsfile[,2])
    maxCV1 <- max(hills$hillsfile[,2])
    minCV2 <- min(hills$hillsfile[,3])
    maxCV2 <- max(hills$hillsfile[,3])
    minCV3 <- min(hills$hillsfile[,4])
    maxCV3 <- max(hills$hillsfile[,4])
    xlims<-c(minCV1-0.05*(maxCV1-minCV1), maxCV1+0.05*(maxCV1-minCV1))
    ylims<-c(minCV2-0.05*(maxCV2-minCV2), maxCV2+0.05*(maxCV2-minCV2))
    zlims<-c(minCV3-0.05*(maxCV3-minCV3), maxCV3+0.05*(maxCV3-minCV3))
    if(!is.null(xlim)) {xlims<-xlim}
    if((hills$per[1]==T)&is.null(xlim)) {xlims<-hills$pcv1}
    if(!is.null(ylim)) {ylims<-ylim}
    if((hills$per[2]==T)&is.null(ylim)) {ylims<-hills$pcv2}
    if(!is.null(zlim)) {zlims<-zlim}
    if((hills$per[3]==T)&is.null(zlim)) {zlims<-hills$pcv3}
    if(hills$per[1]==T) {
      if(min(hills$hillsfile[,2])<xlims[1]) {
        stop("Error: The first collective variable outside pcv1")
      }
      if(max(hills$hillsfile[,2])>xlims[2]) {
        stop("Error: The first collective variable outside pcv1")
      }
    }
    if(hills$per[2]==T) {
      if(min(hills$hillsfile[,3])<ylims[1]) {
        stop("Error: The second collective variable outside pcv2")
      }
      if(max(hills$hillsfile[,3])>ylims[2]) {
        stop("Error: The second collective variable outside pcv2")
      }
    }
    if(hills$per[3]==T) {
      if(min(hills$hillsfile[,4])<zlims[1]) {
        stop("Error: The third collective variable outside pcv3")
      }
      if(max(hills$hillsfile[,4])>zlims[2]) {
        stop("Error: The third collective variable outside pcv3")
      }
    }
    x<-0:(npoints-1)*(xlims[2]-xlims[1])/(npoints-1)+xlims[1]
    y<-0:(npoints-1)*(ylims[2]-ylims[1])/(npoints-1)+ylims[1]
    z<-0:(npoints-1)*(zlims[2]-zlims[1])/(npoints-1)+zlims[1]
    if((hills$per[1]==F)&(hills$per[2]==F)&(hills$per[3]==F)) {
      fesm<-hills3d1(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                     npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                     npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                     npoints*max(hills$hillsfile[,5])/(xlims[2]-xlims[1]),
                     npoints*max(hills$hillsfile[,6])/(ylims[2]-ylims[1]),
                     npoints*max(hills$hillsfile[,7])/(zlims[2]-zlims[1]),
                     hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    if((hills$per[1]==T)&(hills$per[2]==F)&(hills$per[3]==F)) {
      fesm<-hills3d1p1(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                       npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                       npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                       npoints*max(hills$hillsfile[,5])/(xlims[2]-xlims[1]),
                       npoints*max(hills$hillsfile[,6])/(ylims[2]-ylims[1]),
                       npoints*max(hills$hillsfile[,7])/(zlims[2]-zlims[1]),
                       hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    if((hills$per[1]==F)&(hills$per[2]==T)&(hills$per[3]==F)) {
      fesm<-hills3d1p2(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                       npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                       npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                       npoints*max(hills$hillsfile[,5])/(xlims[2]-xlims[1]),
                       npoints*max(hills$hillsfile[,6])/(ylims[2]-ylims[1]),
                       npoints*max(hills$hillsfile[,7])/(zlims[2]-zlims[1]),
                       hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    if((hills$per[1]==F)&(hills$per[2]==F)&(hills$per[3]==T)) {
      fesm<-hills3d1p3(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                       npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                       npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                       npoints*max(hills$hillsfile[,5])/(xlims[2]-xlims[1]),
                       npoints*max(hills$hillsfile[,6])/(ylims[2]-ylims[1]),
                       npoints*max(hills$hillsfile[,7])/(zlims[2]-zlims[1]),
                       hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    if((hills$per[1]==T)&(hills$per[2]==T)&(hills$per[3]==F)) {
      fesm<-hills3d1p12(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                        npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                        npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                        npoints*max(hills$hillsfile[,5])/(xlims[2]-xlims[1]),
                        npoints*max(hills$hillsfile[,6])/(ylims[2]-ylims[1]),
                        npoints*max(hills$hillsfile[,7])/(zlims[2]-zlims[1]),
                        hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    if((hills$per[1]==T)&(hills$per[2]==F)&(hills$per[3]==T)) {
      fesm<-hills3d1p13(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                        npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                        npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                        npoints*max(hills$hillsfile[,5])/(xlims[2]-xlims[1]),
                        npoints*max(hills$hillsfile[,6])/(ylims[2]-ylims[1]),
                        npoints*max(hills$hillsfile[,7])/(zlims[2]-zlims[1]),
                        hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    if((hills$per[1]==F)&(hills$per[2]==T)&(hills$per[3]==T)) {
      fesm<-hills3d1p23(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                        npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                        npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                        npoints*max(hills$hillsfile[,5])/(xlims[2]-xlims[1]),
                        npoints*max(hills$hillsfile[,6])/(ylims[2]-ylims[1]),
                        npoints*max(hills$hillsfile[,7])/(zlims[2]-zlims[1]),
                        hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    if((hills$per[1]==T)&(hills$per[2]==T)&(hills$per[3]==T)) {
      fesm<-hills3d1p123(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                         npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                         npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                         npoints*max(hills$hillsfile[,5])/(xlims[2]-xlims[1]),
                         npoints*max(hills$hillsfile[,6])/(ylims[2]-ylims[1]),
                         npoints*max(hills$hillsfile[,7])/(zlims[2]-zlims[1]),
                         hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    fesm<-aperm(array(fesm, c(npoints, npoints, npoints)))
    cfes<-list(fes=fesm, hills=hills$hillsfile, rows=npoints, dimension=3, per=hills$per,
               x=x, y=y, z=z, pcv1=hills$pcv1, pcv2=hills$pcv2, pcv3=hills$pcv3)
    class(cfes) <- "fes3d"
  }
  return(cfes)
}

#' Calculate 3D free energy surface by conventional algorithm
#'
#' `fes2.hills3d` sums up hills using slow conventional algorithm. It can be used
#' as a reference or when hill widths are variable.
#'
#' @param hills hillsfile3d object.
#' @param imin index of a hill from which summation starts (default 1).
#' @param imax index of a hill from which summation stops (default the rest of hills).
#' @param xlim numeric vector of length 2, giving the CV1 coordinates range.
#' @param ylim numeric vector of length 2, giving the CV2 coordinates range.
#' @param zlim numeric vector of length 2, giving the CV3 coordinates range.
#' @param npoints resolution of the free energy surface in number of points.
#' @return fes object.
#'
#' @export
#' @examples
#' tfes<-fes2(acealanme3d, imax=1000)
fes2.hillsfile3d<-function(hills, imin=1, imax=NULL, xlim=NULL, ylim=NULL, zlim=NULL, npoints=NULL) {
  if(!is.null(imax)) {
    if(hills$size[1]<imax) {
      cat("Warning: You requested more hills by imax than available, using all hills\n")
      imax<-hills$size[1]
    }
  }
  if(is.null(imax)) {
    imax<-hills$size[1]
  }
  if(imin>imax) {
    stop("Error: imax cannot be lower than imin")
  }
  if(hills$size[2]==9) {
    if(is.null(npoints)) {
      npoints <- 64
    }
    minCV1 <- min(hills$hillsfile[,2])
    maxCV1 <- max(hills$hillsfile[,2])
    minCV2 <- min(hills$hillsfile[,3])
    maxCV2 <- max(hills$hillsfile[,3])
    minCV3 <- min(hills$hillsfile[,4])
    maxCV3 <- max(hills$hillsfile[,4])
    xlims<-c(minCV1-0.05*(maxCV1-minCV1), maxCV1+0.05*(maxCV1-minCV1))
    ylims<-c(minCV2-0.05*(maxCV2-minCV2), maxCV2+0.05*(maxCV2-minCV2))
    zlims<-c(minCV3-0.05*(maxCV3-minCV3), maxCV3+0.05*(maxCV3-minCV3))
    if(!is.null(xlim)) {xlims<-xlim}
    if((hills$per[1]==T)&is.null(xlim)) {xlims<-hills$pcv1}
    if(!is.null(ylim)) {ylims<-ylim}
    if((hills$per[2]==T)&is.null(ylim)) {ylims<-hills$pcv2}
    if(!is.null(zlim)) {zlims<-zlim}
    if((hills$per[3]==T)&is.null(zlim)) {zlims<-hills$pcv3}
    x<-0:(npoints-1)*(xlims[2]-xlims[1])/(npoints-1)+xlims[1]
    y<-0:(npoints-1)*(ylims[2]-ylims[1])/(npoints-1)+ylims[1]
    z<-0:(npoints-1)*(zlims[2]-zlims[1])/(npoints-1)+zlims[1]
    if((hills$per[1]==F)&(hills$per[2]==F)&(hills$per[3]==F)) {
      fesm<-hills3d2(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                     npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                     npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                     npoints*hills$hillsfile[,5]/(xlims[2]-xlims[1]),
                     npoints*hills$hillsfile[,6]/(ylims[2]-ylims[1]),
                     npoints*hills$hillsfile[,7]/(zlims[2]-zlims[1]),
                     hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    if((hills$per[1]==T)&(hills$per[2]==F)&(hills$per[3]==F)) {
      fesm<-hills3d2p1(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                       npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                       npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                       npoints*hills$hillsfile[,5]/(xlims[2]-xlims[1]),
                       npoints*hills$hillsfile[,6]/(ylims[2]-ylims[1]),
                       npoints*hills$hillsfile[,7]/(zlims[2]-zlims[1]),
                       hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    if((hills$per[1]==F)&(hills$per[2]==T)&(hills$per[3]==F)) {
      fesm<-hills3d2p2(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                       npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                       npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                       npoints*hills$hillsfile[,5]/(xlims[2]-xlims[1]),
                       npoints*hills$hillsfile[,6]/(ylims[2]-ylims[1]),
                       npoints*hills$hillsfile[,7]/(zlims[2]-zlims[1]),
                       hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    if((hills$per[1]==F)&(hills$per[2]==F)&(hills$per[3]==T)) {
      fesm<-hills3d2p3(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                       npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                       npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                       npoints*hills$hillsfile[,5]/(xlims[2]-xlims[1]),
                       npoints*hills$hillsfile[,6]/(ylims[2]-ylims[1]),
                       npoints*hills$hillsfile[,7]/(zlims[2]-zlims[1]),
                       hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    if((hills$per[1]==T)&(hills$per[2]==T)&(hills$per[3]==F)) {
      fesm<-hills3d2p12(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                        npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                        npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                        npoints*hills$hillsfile[,5]/(xlims[2]-xlims[1]),
                        npoints*hills$hillsfile[,6]/(ylims[2]-ylims[1]),
                        npoints*hills$hillsfile[,7]/(zlims[2]-zlims[1]),
                        hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    if((hills$per[1]==T)&(hills$per[2]==F)&(hills$per[3]==T)) {
      fesm<-hills3d2p13(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                        npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                        npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                        npoints*hills$hillsfile[,5]/(xlims[2]-xlims[1]),
                        npoints*hills$hillsfile[,6]/(ylims[2]-ylims[1]),
                        npoints*hills$hillsfile[,7]/(zlims[2]-zlims[1]),
                        hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    if((hills$per[1]==F)&(hills$per[2]==T)&(hills$per[3]==T)) {
      fesm<-hills3d2p23(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                        npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                        npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                        npoints*hills$hillsfile[,5]/(xlims[2]-xlims[1]),
                        npoints*hills$hillsfile[,6]/(ylims[2]-ylims[1]),
                        npoints*hills$hillsfile[,7]/(zlims[2]-zlims[1]),
                        hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    if((hills$per[1]==T)&(hills$per[2]==T)&(hills$per[3]==T)) {
      fesm<-hills3d2p123(npoints*(hills$hillsfile[,2]-xlims[1])/(xlims[2]-xlims[1]),
                         npoints*(hills$hillsfile[,3]-ylims[1])/(ylims[2]-ylims[1]),
                         npoints*(hills$hillsfile[,4]-zlims[1])/(zlims[2]-zlims[1]),
                         npoints*hills$hillsfile[,5]/(xlims[2]-xlims[1]),
                         npoints*hills$hillsfile[,6]/(ylims[2]-ylims[1]),
                         npoints*hills$hillsfile[,7]/(zlims[2]-zlims[1]),
                         hills$hillsfile[,8],npoints,imin-1,imax-1)
    }
    fesm<-aperm(array(fesm, c(npoints, npoints, npoints)))
    cfes<-list(fes=fesm, hills=hills$hillsfile, rows=npoints, dimension=3, per=hills$per,
               x=x, y=y, z=z, pcv1=hills$pcv1, pcv2=hills$pcv2, pcv3=hills$pcv3)
    class(cfes) <- "fes3d"
  }
  return(cfes)
}

#' @export
`+.fes3d`<-function(fes1, fes2) {
  if((class(fes1)=="fes3d")&(class(fes2)=="fes3d")) {
    if(fes1$rows!=fes2$rows) {
      stop("Error: Free energy surfaces have different numbers of points, exiting")
    }
    if(sum(fes1$x!=fes2$x)>0) {
      stop("Error: Free energy surfaces have different CV1 axes, exiting")
    }
    if(sum(fes1$y!=fes2$y)>0) {
      stop("Error: Free energy surfaces have different CV2 axes, exiting")
    }
    if(sum(fes1$z!=fes2$z)>0) {
      stop("Error: Free energy surfaces have different CV3 axes, exiting")
    }
    cfes<-list(fes=fes1$fes+fes2$fes, hills=rbind(fes1$hills, fes2$hills), rows=fes1$rows, dimension=fes1$dimension, per=fes1$per, x=fes1$x, y=fes1$y, z=fes1$z, pcv1=fes1$pcv1, pcv2=fes1$pcv2, pcv3=fes1$pcv3)
  } else if(class(fes1)=="fes3d") {
    cfes<-list(fes=fes1$fes+fes2, hills=fes1$hills, rows=fes1$rows, dimension=fes1$dimension, per=fes1$per, x=fes1$x, y=fes1$y, z=fes1$z, pcv1=fes1$pcv1, pcv2=fes1$pcv2, pcv3=fes1$pcv3)
  } else if(class(fes2)=="fes3d") {
    cfes<-list(fes=fes1+fes2$fes, hills=rbind(fes1$hills,fes2$hills), rows=fes2$rows, dimension=fes2$dimension, per=fes2$per, x=fes2$x, y=fes2$y, z=fes2$z, pcv1=fes2$pcv1, pcv2=fes2$pcv2, pcv3=fes2$pcv3)
  } else if(class(fes1)=="fes") {
    stop("Error: cannot sum 3D free energy surfaces with 1D or 2D, exiting")
  } else if(class(fes2)=="fes") {
    stop("Error: cannot sum 3D free energy surfaces with 1D or 2D, exiting")
  }
  class(cfes) <- "fes3d"
  return(cfes)
}

#' @export
`-.fes3d`<-function(fes1, fes2) {
  if((class(fes1)=="fes3d")&(class(fes2)=="fes3d")) {
    if(fes1$rows!=fes2$rows) {
      stop("Error: Free energy surfaces have different numbers of points, exiting")
    }
    if(fes1$dimension!=fes2$dimension) {
      stop("Error: Free energy surfaces have different dimension, exiting")
    }
    if(sum(fes1$x!=fes2$x)>0) {
      stop("Error: Free energy surfaces have different CV1 axes, exiting")
    }
    if(sum(fes1$y!=fes2$y)>0) {
      stop("Error: Free energy surfaces have different CV2 axes, exiting")
    }
    if(sum(fes1$z!=fes2$z)>0) {
      stop("Error: Free energy surfaces have different CV3 axes, exiting")
    }
    cat("Warning: FES obtained by subtraction of two FESes\n")
    cat(" will inherit hills only from the first FES\n")
    cfes<-list(fes=fes1$fes-fes2$fes, hills=fes1$hills, rows=fes1$rows, dimension=fes1$dimension, per=fes1$per, x=fes1$x, y=fes1$y, z=fes1$z, pcv1=fes1$pcv1, pcv2=fes1$pcv2, pcv3=fes1$pcv3)
  } else if(class(fes1)=="fes3d") {
    cfes<-list(fes=fes1$fes-fes2, hills=fes1$hills, rows=fes1$rows, dimension=fes1$dimension, per=fes1$per, x=fes1$x, y=fes1$y, z=fes1$z, pcv1=fes1$pcv1, pcv2=fes1$pcv2, pcv3=fes1$pcv3)
  } else if(class(fes2)=="fes3d") {
    cfes<-list(fes=fes1-fes2$fes, hills=fes2$hills, rows=fes2$rows, dimension=fes2$dimension, per=fes2$per, x=fes2$x, y=fes2$y, z=fes2$z, pcv1=fes2$pcv1, pcv2=fes2$pcv2, pcv3=fes2$pcv3)
  } else if(class(fes1)=="fes") {
    stop("Error: cannot subtract 3D free energy surfaces with 1D or 2D, exiting")
  } else if(class(fes2)=="fes") {
    stop("Error: cannot subtract 3D free energy surfaces with 1D or 2D, exiting")
  }
  class(cfes) <- "fes3d"
  return(cfes)
}

#' @export
`*.fes3d`<-function(fes1, fes2) {
  if((class(fes1)=="fes3d")&(class(fes2)=="fes3d")) {
    stop("Error: You cannot multiply fes by fes")
  } else if(class(fes1)=="fes3d") {
    cfes<-list(fes=fes1$fes*fes2, hills=fes1$hills, rows=fes1$rows, dimension=fes1$dimension, per=fes1$per, x=fes1$x, y=fes1$y, z=fes1$z, pcv1=fes1$pcv1, pcv2=fes1$pcv2, pcv3=fes1$pcv3)
  } else if(class(fes2)=="fes3d") {
    cfes<-list(fes=fes1*fes2$fes, hills=fes2$hills, rows=fes2$rows, dimension=fes2$dimension, per=fes2$per, x=fes2$x, y=fes2$y, z=fes2$z, pcv1=fes2$pcv1, pcv2=fes2$pcv2, pcv3=fes2$pcv3)
  }
  cat("Warning: multiplication of FES will multiply\n")
  cat(" the FES but not hill heights\n")
  class(cfes) <- "fes3d"
  return(cfes)
}

#' @export
`/.fes3d`<-function(fes1, coef) {
  if((class(fes1)=="fes3d")&(class(coef)=="fes3d")) {
    stop("Error: You cannot divide fes by fes")
  } else if(class(fes1)=="fes3d") {
    cfes<-list(fes=fes1$fes/coef, hills=fes1$hills, rows=fes1$rows, dimension=fes1$dimension, per=fes1$per, x=fes1$x, y=fes1$y, z=fes1$z, pcv1=fes1$pcv1, pcv2=fes1$pcv2, pcv3=fes1$pcv3)
  } else if(class(coef)=="fes3d") {
    stop("Error: You cannot divide something by fes")
  }
  cat("Warning: division of FES will divide\n")
  cat(" the FES but not hill heights\n")
  class(cfes) <- "fes3d"
  return(cfes)
}

#' Calculate minimum of 3D free energy surface
#'
#' `min.fes3d` calculates minimum of free energy in a fes3d object.
#'
#' @param inputfes fes3d object.
#' @param na.rm a logical indicating whether missing values should be
#'        removed.
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' tfes<-fes(acealanme3d, imax=5000)
#' min(tfes)
min.fes3d<-function(inputfes, na.rm=NULL,...) {
  return(min(inputfes$fes, na.rm=na.rm))
}

#' Calculate maximum of 3D free energy surface
#'
#' `max.fes3d` calculates maximum of free energy in a fes3d object.
#'
#' @param inputfes fes3d object.
#' @param na.rm a logical indicating whether missing values should be
#'        removed.
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' tfes<-fes(acealanme3d, imax=5000)
#' max(tfes)
max.fes3d<-function(inputfes, na.rm=NULL,...) {
  return(max(inputfes$fes, na.rm=na.rm))
}

#' Print minimum and maximum of 3D free energy surface
#'
#' `print.fes3d` prints dimensionality, minimum and maximum of
#' free energy in a fes object
#'
#' @param x fes3d object
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' tfes<-fes(acealanme3d, imax=5000)
#' tfes
print.fes3d<-function(x,...) {
  inputfes<-x
  cat("3D free energy surface with ")
  cat(inputfes$rows)
  cat(" x ")
  cat(inputfes$rows)
  cat(" x ")
  cat(inputfes$rows)
  cat(" points, maximum ")
  cat(max(inputfes$fes))
  cat(" and minimum ")
  cat(min(inputfes$fes))
  cat("\n")
}

#' Print summary of 3D free energy surface
#'
#' `summary.fes3d` prints minimum and maximum of free energy
#' in a fes object.
#'
#' @param object fes3d object.
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' tfes<-fes(acealanme3d, imax=5000)
#' summary(tfes)
summary.fes3d<-function(object,...) {
  inputfes <- object
  cat("3D free energy surface with ")
  cat(inputfes$rows)
  cat(" x ")
  cat(inputfes$rows)
  cat(" x ")
  cat(inputfes$rows)
  cat(" points, maximum ")
  cat(max(inputfes$fes))
  cat(" and minimum ")
  cat(min(inputfes$fes))
  cat("\n")
}

#' Plot 3D free energy surface object
#'
#' `plot.fes3d` plots 3D free energy surface using .
#'
#' @param x fes3d object.
#' @param xlab a title for the x axis: see 'title'.
#' @param ylab a title for the y axis: see 'title'.
#' @param zlab a title for the z axis: see 'title'.
#' @param col color of the free energy surface. It can be a single color
#'        or a vector with multiple colors for multiple 3D isosurfaces.
#' @param alpha number or numeric vector of alpha levels (transparency) of
#'        3D isosurfaces.
#' @param xlim numeric vector of length 2, giving the x coordinates range.
#' @param ylim numeric vector of length 2, giving the y coordinates range.
#' @param zlim numeric vector of length 2, giving the z coordinates range.
#' @param main an overall title for the plot: see 'title'.
#' @param sub a sub title for the plot: see 'title'.
#' @param level number or numeric vector of levels at which to draw 3D isosurface.
#' @param fill a logical value indicating whether 3D isosurface is ploted as
#'        solid surface (True) or wireframe (False).
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' tfes3d<-fes(acealanme3d, imax=5000)
#' plot(tfes3d)
plot.fes3d<-function(x, xlim=NULL, ylim=NULL, zlim=NULL,
                     xlab=NULL, ylab=NULL, zlab=NULL,
                     level=NULL, col=NULL, alpha=NULL,
                     main=NULL, sub=NULL,
                     fill=T,...) {
  close.screen(all.screens=TRUE)
  inputfes<-x
  fes<-inputfes$fes
  rows<-inputfes$rows
  x<-inputfes$x
  y<-inputfes$y
  z<-inputfes$z
  if(is.null(xlab)) xlab="CV1"
  if(is.null(ylab)) ylab="CV2"
  if(is.null(zlab)) zlab="CV3"
  if(is.null(level)) level=(max(fes)+min(fes))/2
  if(length(level)>1) {
    if(is.null(col)) col<-rainbow(1.35*length(level))[length(level):1]
    if(is.null(alpha)) {
      alpha<-length(level):1/length(level)
      level<-sort(level)
    }
  } else {
    if(is.null(col)) col<-"orange"
    if(is.null(alpha)) alpha<-1
  }
  contour3d(f=fes, level=level, x=x, y=y, z=z, 
            color=col, alpha=alpha, fill=fill)
  axes3d()
  title3d(xlab=xlab, ylab=ylab, zlab=zlab, main=main, sub=sub)
  box3d()
}

